# 低レイヤ基礎の最終確認

以下の3つのアセンブラコードから、元のCソースコードを予測してみましょう。
ただCソースコードはどれも10行未満なので、焦らず取り組んでみてください。

## 1問目
```
 0x0000000000001135 <+0>:     push   %rbp
 0x0000000000001136 <+1>:     mov    %rsp,%rbp
 0x0000000000001139 <+4>:     sub    $0x10,%rsp
 0x000000000000113d <+8>:     movl   $0x77706c63,-0x6(%rbp)
 0x0000000000001144 <+15>:    movw   $0x6e,-0x2(%rbp)
 0x000000000000114a <+21>:    lea    -0x6(%rbp),%rax
 0x000000000000114e <+25>:    mov    %rax,%rdi
 0x0000000000001151 <+28>:    call   0x1030 <puts@plt>
 0x0000000000001156 <+33>:    mov    $0x0,%eax
 0x000000000000115b <+38>:    leave
 0x000000000000115c <+39>:    ret
 ```
 
 ## 2問目
 ```
 0x0000000000001135 <+0>:     push   %rbp
 0x0000000000001136 <+1>:     mov    %rsp,%rbp
 0x0000000000001139 <+4>:     sub    $0x10,%rsp
 0x000000000000113d <+8>:     movl   $0x5,-0x4(%rbp)
 0x0000000000001144 <+15>:    cmpl   $0x0,-0x4(%rbp)
 0x0000000000001148 <+19>:    jle    0x1160 <main+43>
 0x000000000000114a <+21>:    mov    -0x4(%rbp),%eax
 0x000000000000114d <+24>:    mov    %eax,%esi
 0x000000000000114f <+26>:    lea    0xeae(%rip),%rdi        # 0x2004
 0x0000000000001156 <+33>:    mov    $0x0,%eax
 0x000000000000115b <+38>:    call   0x1030 <printf@plt>
 0x0000000000001160 <+43>:    mov    $0x0,%eax
 0x0000000000001165 <+48>:    leave
 0x0000000000001166 <+49>:    ret
 ```
 
 ## 3問目
 ```
 0x08049162 <+0>:     lea    0x4(%esp),%ecx
 0x08049166 <+4>:     and    $0xfffffff0,%esp
 0x08049169 <+7>:     push   -0x4(%ecx)
 0x0804916c <+10>:    push   %ebp
 0x0804916d <+11>:    mov    %esp,%ebp
 0x0804916f <+13>:    push   %ebx
 0x08049170 <+14>:    push   %ecx
 0x08049171 <+15>:    sub    $0x10,%esp
 0x08049179 <+23>:    add    $0x2e87,%ebx
 0x0804917f <+29>:    movl   $0x1,-0xc(%ebp)
 0x08049186 <+36>:    jmp    0x80491a1 <main+63>
 0x08049188 <+38>:    sub    $0x8,%esp
 0x0804918b <+41>:    push   -0xc(%ebp)
 0x0804918e <+44>:    lea    -0x1ff8(%ebx),%eax
 0x08049194 <+50>:    push   %eax
 0x08049195 <+51>:    call   0x8049030 <printf@plt>
 0x0804919a <+56>:    add    $0x10,%esp
 0x0804919d <+59>:    addl   $0x1,-0xc(%ebp)
 0x080491a1 <+63>:    cmpl   $0x3,-0xc(%ebp)
 0x080491a5 <+67>:    jle    0x8049188 <main+38>
 0x080491a7 <+69>:    mov    $0x0,%eax
 0x080491ac <+74>:    lea    -0x8(%ebp),%esp
 0x080491af <+77>:    pop    %ecx
 0x080491b0 <+78>:    pop    %ebx
 0x080491b1 <+79>:    pop    %ebp
 0x080491b2 <+80>:    lea    -0x4(%ecx),%esp
 0x080491b5 <+83>:    ret
 ```



---



# ヒント
理解すべき部分とそうでない部分を見分け、適切に読み解いていくことが大事になってきます。

## 1問目 - 文字列出力
```
 0x0000000000001135 <+0>:     push   %rbp
 0x0000000000001136 <+1>:     mov    %rsp,%rbp
 0x0000000000001139 <+4>:     sub    $0x10,%rsp
 0x000000000000113d <+8>:     movl   $0x77706c63,-0x6(%rbp)
 0x0000000000001144 <+15>:    movw   $0x6e,-0x2(%rbp)
 # 出力するための文字をスタックに積む部分。
 # ただ、出力する文字が5文字と中途半端なので、4+1文字に分けてmovしています。
 # 順序に注意。最初に4文字を逆順で積み(リトルエンディアン)、最後に５文字目を積んでいます
 # 文字はASCIIコード表記。対応表: http://www12.plala.or.jp/mz80k2/electronics/ascii/ascii.html
 # -0x6(%rbp) は[rbp-0x6]という意味です
 0x000000000000114a <+21>:    lea    -0x6(%rbp),%rax
 0x000000000000114e <+25>:    mov    %rax,%rdi
 0x0000000000001151 <+28>:    call   0x1030 <puts@plt>
 0x0000000000001156 <+33>:    mov    $0x0,%eax
 0x000000000000115b <+38>:    leave
 0x000000000000115c <+39>:    ret
 ```
 
 ```
 出力結果: clpwn
 ```
 
 
 ## 2問目 - if文
 ```
 0x0000000000001135 <+0>:     push   %rbp
 0x0000000000001136 <+1>:     mov    %rsp,%rbp
 0x0000000000001139 <+4>:     sub    $0x10,%rsp
 0x000000000000113d <+8>:     movl   $0x5,-0x4(%rbp)
 0x0000000000001144 <+15>:    cmpl   $0x0,-0x4(%rbp)
 # 0x5を[rbp-0x4]に積み、0x0を[rbp-0x4]に格納されている値(つまり5)と比較している
 0x0000000000001148 <+19>:    jle    0x1160 <main+43>
 # 比較結果を基に命令をジャンプします。
 # ここでは、比較した結果が0より大きければジャンプせず
 # 0より小さければ 0x0000000000001160 <+43>: にジャンプします
 0x000000000000114a <+21>:    mov    -0x4(%rbp),%eax
 0x000000000000114d <+24>:    mov    %eax,%esi
 0x000000000000114f <+26>:    lea    0xeae(%rip),%rdi        # 0x2004
 0x0000000000001156 <+33>:    mov    $0x0,%eax
 0x000000000000115b <+38>:    call   0x1030 <printf@plt>
 0x0000000000001160 <+43>:    mov    $0x0,%eax
 0x0000000000001165 <+48>:    leave
 0x0000000000001166 <+49>:    ret
 ```
 
 ```
 出力結果: 5
 ```
 
 ## 3問目 - ループ
 ```
 0x08049162 <+0>:     lea    0x4(%esp),%ecx
 0x08049166 <+4>:     and    $0xfffffff0,%esp
 0x08049169 <+7>:     push   -0x4(%ecx)
 0x0804916c <+10>:    push   %ebp
 0x0804916d <+11>:    mov    %esp,%ebp
 0x0804916f <+13>:    push   %ebx
 0x08049170 <+14>:    push   %ecx
 0x08049171 <+15>:    sub    $0x10,%esp
 0x08049179 <+23>:    add    $0x2e87,%ebx
 0x0804917f <+29>:    movl   $0x1,-0xc(%ebp)
 # カウンタ変数をセット。
 0x08049186 <+36>:    jmp    0x80491a1 <main+63>
 # 無条件で 0x80491a1 にジャンプ。
 0x08049188 <+38>:    sub    $0x8,%esp
 0x0804918b <+41>:    push   -0xc(%ebp)
 # printf実行前、カウンタ変数の値をpushしている。
 0x0804918e <+44>:    lea    -0x1ff8(%ebx),%eax
 0x08049194 <+50>:    push   %eax
 # 上2行は、eaxレジスタの対比を行なっているだけであり、今回の問題では無視してOK
 0x08049195 <+51>:    call   0x8049030 <printf@plt>
 0x0804919a <+56>:    add    $0x10,%esp
 0x0804919d <+59>:    addl   $0x1,-0xc(%ebp)
 # カウンタ変数に1加算
 0x080491a1 <+63>:    cmpl   $0x3,-0xc(%ebp)
 # 3とカウンタ変数を比較
 0x080491a5 <+67>:    jle    0x8049188 <main+38>
 # (i <= 3)であれば、0x8049188にジャンプ。
 0x080491a7 <+69>:    mov    $0x0,%eax
 0x080491ac <+74>:    lea    -0x8(%ebp),%esp
 0x080491af <+77>:    pop    %ecx
 0x080491b0 <+78>:    pop    %ebx
 0x080491b1 <+79>:    pop    %ebp
 0x080491b2 <+80>:    lea    -0x4(%ecx),%esp
 0x080491b5 <+83>:    ret
 ```
 
 ```
 出力結果: 123
 ```
